/*
A simple schwaemm implementation in Jasmin
*/

from functions require "sparkle3847.jazz"
from functions require "sparkle38411.jazz"
from functions require "feedback_function_1.jazz"
from functions require "feedback_function_2.jazz"
from utils require "pad_256.jazz"
from utils require "W_128_256.jazz"
from utils require "initialize_padding_constants.jazz"
from utils require "pre_sparkle_padding.jazz"

export
fn schwaemm(reg u128 K, reg u256 N, reg u64 A_start, reg u64 A_end, reg u64 M_start, reg u64 M_end, reg u64 output_ptr) -> reg u128 { 

  reg u256 SL;
  reg u128 SR;

  reg u64 A_lenght;
  reg u64 M_lenght;

  A_lenght = A_end;
  A_lenght -= A_start;
  M_lenght = M_end;
  M_lenght -= M_start;

  stack u64 A_lenght_save;
  stack u64 M_lenght_save;
  M_lenght_save = M_lenght;

  reg u128 constA;
  reg u128 constM;

  stack u128 constA_save;
  stack u128 constM_save;

  reg u64 x;
  reg u64 y;

  M_lenght = M_lenght_save;

  constA, constM = initialize_padding_constants(A_lenght, M_lenght);

  constA_save = constA;
  constM_save = constM;

  M_lenght_save = M_lenght;

  if A_lenght != 0 {
    while ((A_lenght) < 256) {
      inline u256 feedback_1_result;
      inline u256 W_result;

      inline u256 A_block;
      A_block = (256u)[A_start];

      stack u64 A_start_save;
      A_start_save = A_start;

      feedback_1_result = feedback_function_1(SL, A_block);
      W_result = W_128_256(SR);

      feedback_1_result ^= W_result;

      x,y = pre_sparkle_padding(feedback_1_result, SR);

      SL, SR = sparkle3847(x,y);

      A_start = A_start_save;

      A_start += 32;

      A_lenght -= 32;
    }

    inline u256 feedback_1_result;
    inline u256 W_result;
    reg u256 zero;
    
    zero = #set0_256();
    stack u8[32] t;
    t.[u256 0] = zero;

    reg u256 A_block;
    reg u64 i;
    i=0;

    while (i<A_lenght) {
      t[i] = (u8)[A_start + i];
      i += 1;
    }
    t[i] = 1;

    A_block = t.[u256 0];

    constA = constA_save;

    SR ^= constA;

    constA_save = constA;

    feedback_1_result = feedback_function_1(SL, A_block);
    W_result = W_128_256(SR);
    feedback_1_result ^= W_result;

    x,y = pre_sparkle_padding(feedback_1_result, SR);

    SL, SR = sparkle38411(x,y);

  }

  A_lenght_save = A_lenght;

  M_lenght = M_lenght_save;

  if M_lenght != 0 {
    while ((M_lenght) < 256) {

      M_lenght_save = M_lenght;

      inline u256 feedback_1_result;
      inline u256 W_result;

      inline u256 M_block;
      M_block = (256u)[M_start];

      feedback_1_result = feedback_function_1(SL, M_block);
      W_result = W_128_256(SR);

      feedback_1_result ^= W_result;

      x,y = pre_sparkle_padding(feedback_1_result, SR);

      SL, SR = sparkle3847(x,y);

      M_start += 32;

      M_lenght = M_lenght_save; 

      M_lenght -= 32;

      M_lenght_save = M_lenght;
    }

    inline u256 feedback_1_result;
    inline u256 W_result;
    reg u256 zero;
    
    zero = #set0_256();
    stack u8[32] t;
    t.[u256 0] = zero;

    reg u256 M_block;
    reg u64 i;
    i=0;

    while (i<M_lenght) {
      t[i] = (u8)[M_start + i];
      i += 1;
    }
    t[i] = 1;

    M_block = t.[u256 0];

    constM = constM_save;

    SR ^= constM;

    constM_save = constM;

    feedback_1_result = feedback_function_2(SL, M_block);
    W_result = W_128_256(SR);
    feedback_1_result ^= W_result;

    x,y = pre_sparkle_padding(feedback_1_result, SR);

    SL, SR = sparkle38411(x, y);
  }
  
  return SR;
}
