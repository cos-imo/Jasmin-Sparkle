/*
A simple Esch implementation in Jasmin
*/

from functions require "sparkle384.jazz"
from functions require "M3.jazz"

export
fn esch(reg u64 M_start, reg u64 M_end, reg u64 output_ptr) { 

  reg u32 constM;
  reg u128 D_0;
  reg u128 D_1;
  reg u256 res;
  reg u64 M_lenght;


  M_lenght = M_end;
  M_lenght -= M_start;

  stack u32[12] S;

  reg u32 zero;
  ?{},zero = #set0_32();

  inline int j;
  for j=0 to 12 {
    S[j] = zero;
  }

  // MAIN LOOP

  if M_end != M_start {
    while (M_lenght < 128) {
      inline int i;
      stack u32[4] M_block_tab;
      stack u32[6] M3_tab;
    

      for i=0 to 4 {
        M3_tab[i] = (u32)[M_start + 4*i];
      }

      M3_tab[4] = zero;
      M3_tab[5] = zero;

      M3_tab = M3(M3_tab);

      for i=0 to 4 {
        reg u32 l;
        l = M3_tab[i];
        S[i] ^= l;
      }

      S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);

      M_start += 32;
      M_lenght = M_end;
      M_lenght -= M_start;
    }


    // LAST BLOCK

    stack u32[6] M_block;

    inline int i;
    for i=0 to 6 {
      M_block[i] = zero;
    }

    reg u64 i;

    i=0;

    while (M_lenght>0) {
      reg u32 l;
      l = (u32)[M_start];
      S[i] ^= l;
      M_start += 32;
      i += 1;
      // i = i%12;
      M_lenght = M_end;
      M_lenght-=M_start;
    }

    // PADDING

    if i<6 {
      S[u8 i] ^= 1;
      constM = 1;
    } else {
      constM =2;
    }

    S[6] ^= constM;


    // D_0
     
    inline int j;

    for j=0 to 4 {
      (u32)[output_ptr + 4*j] = S[j];
    }

    S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);


    // D_1

    inline int k;

    for k=0 to 4 {
      (u32)[output_ptr + 16 + 4*k] = S[k];
    }

  } 

}

