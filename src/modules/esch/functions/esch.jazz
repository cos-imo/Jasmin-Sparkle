/*
A simple Esch implementation in Jasmin
*/

from sparkle require "sparkle384.jazz"
from functions require "M3.jazz"

fn 
M3_XOR_S(reg u64 M_start, reg ptr u32[12] S) -> reg ptr u32[12] {
  reg u32 zero;
  ?{},zero = #set0_32();

  inline int i;
  stack u32[6] M3_tab;

  for i=0 to 4 {
    M3_tab[i] = (u32)[M_start + 4*i];
  }

  M3_tab[4] = zero;
  M3_tab[5] = zero;

  M3_tab = M3(M3_tab);

  for i=0 to 4 {
    reg u32 l;
    l = M3_tab[i];
    S[i] ^= l;
  }

  return S;
}

export
fn esch(reg u64 M_start, reg u64 M_end, reg u64 output_ptr) { 

  reg u32 constM;
  reg u128 D_0;
  reg u128 D_1;
  reg u64 M_lenght;


  M_lenght = M_end;
  M_lenght -= M_start;

  stack u32[12] S;

  reg u32 zero;
  ?{},zero = #set0_32();

  inline int j;
  for j=0 to 12 {
    S[j] = zero;
  }

  // MAIN LOOP

  if M_end != M_start {
    while (M_lenght > 128) {
      S = M3_XOR_S(M_start, S);  // padd + apply M3

      S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);

      M_start += 32;
      M_lenght = M_end;
      M_lenght -= M_start;
    }


    // LAST BLOCK

    stack u32[6] M_block;

    inline int i;
    for i=0 to 6 {
      M_block[i] = zero;
    }

    reg u64 i;

    i=0;

    while (M_lenght>0) {
      reg u32 l;
      l = (u32)[M_start];
      S[i] ^= l;
      M_start += 32;
      i += 1;
      M_lenght = M_end;
      M_lenght-=M_start;
    }

    // PADDING

    if i<6 {
      S[u8 i] ^= 1;
      constM = 1;
    } else {
      constM =2;
    }

    S[6] ^= constM;


    // D_0
     
    inline int j;

    for j=0 to 4 {
      (u32)[output_ptr + j] = S[j];
    }

    S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);


    // D_1

    inline int k;

    for k=0 to 4 {
      (u32)[output_ptr + 16 + k] = S[k];
    }

  } 

}

