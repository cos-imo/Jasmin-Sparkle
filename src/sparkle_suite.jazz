require "alzette.jazz"
require "crax.jazz"
//require "esch.jazz"
//require "schwaemm.jazz"
require "sparkle384.jazz"

export
fn crax_export(reg u32 xword, reg u32 yword, reg u32 key_0, reg u32 key_1, reg u32 key_2, reg u32 key_3) -> reg u64 {
	reg u32 xword, yword;
	reg u64 export_var, padded_y;

	xword, yword = crax(xword, yword, key_0, key_1, key_2, key_3);

	export_var = (64u) xword;
	export_var>>r=32;
	padded_y = (64u) yword;
	export_var += padded_y;

	return export_var;
}

/*
export
fn esch_export(reg u64 M_start, reg u64 M_end, reg u64 output_ptr) {
	esch(M_Start, M_end, output_ptr);
}


export
fn schwaemm_export(reg u128 K, reg u256 N, reg u64 A_start, reg u64 A_end, reg u64 M_start, reg u64 M_end, reg u64 output_ptr) -> reg u128 {
	reg u128 res;

	res = schwaemm(K, N, A_start, A_end, M_start, M_end, output_ptr);

	return res;

}

*/
export
fn sparkle384_11_export(reg u64 SL_ptr, reg u64 SR_ptr) {

  SL_ptr = SL_ptr;
  SR_ptr = SR_ptr;

  stack u32[8] SL;
  stack u32[4] SR;

  inline int i;

  for i=0 to 8 {
	SL[i] = (u32)[SL_ptr + 4*i];
  }

  for i=0 to 4 {
	SR[i] = (u32)[SR_ptr + 4*i];
  }

  SL, SR = sparkle384(SL, SR, 11);

  for i=0 to 8 {
	(u32)[SL_ptr + 4*i] = SL[i];
  }

  for i=0 to 4 {
	(u32)[SR_ptr + 4*i] = SR[i];
  }
}

export
fn sparkle384_7_export(reg u64 SL_ptr, reg u64 SR_ptr) {

  SL_ptr = SL_ptr;
  SR_ptr = SR_ptr;

  stack u32[8] SL;
  stack u32[4] SR;

  inline int i;

  for i=0 to 8 {
	SL[i] = (u32)[SL_ptr + 4*i];
  }

  for i=0 to 4 {
	SR[i] = (u32)[SR_ptr + 4*i];
  }

  SL, SR = sparkle384(SL, SR, 7);

  for i=0 to 8 {
	(u32)[SL_ptr + 4*i] = SL[i];
  }

  for i=0 to 4 {
	(u32)[SR_ptr + 4*i] = SR[i];
  }

}

export
fn alzette_export(reg u32 c, reg u32 x, reg u32 y) -> reg u64 { //renvoyer sur 64 bits
	reg u32 x_out, y_out;

	reg u64 res;
	reg u64 padded_y;
	x,y= alzette(c, x, y);

	res = (64u) x;
	res >>r=32;
	padded_y = (64u) y;
	res += padded_y;

	return res;
}
