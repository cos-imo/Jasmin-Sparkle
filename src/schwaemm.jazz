/*
A simple Schwaemm implementation in Jasmin
*/

require "sparkle384.jazz"

inline
fn stack_u256_to_tab(stack u256 data) -> stack u32[8] {
  stack u32[8] tab;
  reg u256 rotated_data;
  inline int i;

  rotated_data = data;

  for i=0 to 7 {
    tab[i] = rotated_data & 0xFF;
    rotated_data >>= 32;
  }

  return tab;

}

inline
fn stack_u128_to_tab(stack u128 data) -> reg u32[4] {
  reg u32[4] tab;
  reg u128 rotated_data;
  inline int i;

  rotated_data = data;

  for i=0 to 3 {
    tab[i] = rotated_data & 0xFF;
    rotated_data >>= 32;
  }

  return tab;

}

inline
fn W_128_256(stack u32[4] arg) -> stack u32[8] {
  stack u32[8] res;
  inline int i;

  for i=0 to 4{
        res[i] = arg[i];
        res[i+4] = arg[i];
  }

  return res;
}

inline
fn FeistelSwap(stack u32[8] S) -> stack u32[8] {


  inline int i;

  for i=0 to 4 {
    S[i] ^= S[7-i];
  }

  for i=4 to 8 {
    inline u32 save;
    save = S[i];
    S[i] = S[8-i];
    S[8-i] = save;
  }

  return S;
}

inline
fn feedback_function_1(stack u32[8] S, stack u32[8] D) -> stack u32[8] {

  S = FeistelSwap(S);
  
  inline int i;
  for i=0 to 8{
    S[i]^=D[i];
  }

  return S;

}

inline
fn feedback_function_2(reg u256 S, reg u256 D) -> reg u256 {

  D^=S;

  return D;

}

inline
fn initialize_padding_constants(reg u64 Alen, reg u64 Mlen) -> reg u64, reg u64 {
  reg u64 constA;
  reg u64 constM;
  reg bool zf;
  
  ?{zf} = #TEST(Alen,31);

  if (zf) {
    constA = 5;
  } else {
    constA = 4;
  }

  ?{zf} = #TEST(Mlen,31);

  if (zf) {
    constM = 7;
  } else {
    constM = 6;
  }

  return constA, constM;
}

inline
fn schwaemm(stack u32[4] K, stack u32[8] N, reg u64 A_start, reg u64 A_end, reg u64 M_start, reg u64 M_end, reg u64 output_ptr) { 

  reg u32 constM;
  reg u32 constA;
  reg u64 M_lenght;
  reg u64 A_lenght;

  stack u32[8] SL;
  stack u32[4] SR;

  A_lenght = A_end;
  A_lenght -= A_start;

  M_lenght = M_end;
  M_lenght -= M_start;

  inline int i;

  for i=0 to 8{
        SL[i] = N[i];
  }

  for i=0 to 4{
        SR[i] = K[i];
  }

  SL, SR = sparkle384_7(SL,SR); 

  // MAIN LOOP

  while (A_lenght > 32) {

    stack u32[8] W_result;

    reg u256 A_block;
    stack u32[8] A_block_tab;
    A_block = (256u)[A_start];
    A_block_tab = stack_u256_to_tab(A_block);

    SL = feedback_function_1(SL, A_block_tab);
    W_result = W_128_256(SR);

    for i=0 to 8 {
            SL[i] ^= W_result[i];
    }

    SL, SR= sparkle384(SL,SR,7);

    A_start += 32;
    A_lenght = M_end;
    A_lenght -= M_start;
  }

  while (M_lenght > 32) {

    stack u32[8] feedback_1_result;
    stack u32[8] W_result;

    reg u256 M_block;
    stack u32[8] M_block_tab;
    M_block = (256u)[M_start];
    M_block_tab = stack_u256_to_tab(M_block);

    feedback_1_result = feedback_function_1(SL, M_block_tab);
    W_result = W_128_256(SR);

    for i=0 to 8 {
            feedback_1_result[i] ^= W_result[i];
    }

    SL, SR = sparkle384(feedback_1_result,SR,7);

    M_start += 16;
    M_lenght = M_end;
    M_lenght -= M_start;
  }

  // LAST BLOCK

  stack u8[24] t;

  inline int j;
  for j=0 to 24 {
    t[j] = 0;
  }

  reg u64 i;
  ?{},i=#set0_64();

  while (i<M_lenght) {
    t[i] = (u8)[M_start + i];
    i += 1;
  }
  
  // PADDING

  if i<16 {
    reg u8 var_1;
    var_1 = 0x80;
    t[u8 i] = var_1;
    constM = 1<<24;
  } else {
    constM =2<<24;
  }

  t[u32 0:6] = M3(t[u32 0:6]);

  SR[0] ^= constM;

  for j=0 to 6 {
    reg u32 t_val;
    t_val = t[u32 j];
    SL[j] ^= t_val;
  }

  SL, SR = sparkle384_11(SL, SR);

  // D_0
   
  for j=0 to 4 {
    (u32)[output_ptr + 4*j] = SL[j];
  }

  SL, SR = sparkle384_7(SL, SR);

  // D_1

  inline int k;

  for k=0 to 4 {
    (u32)[output_ptr + 16 + 4*k] = SL[k];
  }


}

