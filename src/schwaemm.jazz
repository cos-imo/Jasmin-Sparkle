/*
A simple Schwaemm implementation in Jasmin
*/

require "sparkle384.jazz"

inline
fn get_32x8_tab(reg u64 position) -> reg u32[8] {

  reg u32[8] tab;
  inline int i;

  for i=0 to 8 {
    tab[i] = (u32)[position + 2*i];
  }

  return tab;

}

inline
fn get_32x4_tab(reg u64 position) -> stack u32[4] {

  stack u32[4] tab;
  inline int i;

  for i=0 to 4{
    tab[i] = (u32)[position + 2*i];
  }

  return tab;

}

inline
fn W_128_256(stack u32[4] arg) -> stack u32[8] {
  stack u32[8] res;
  inline int i;

  for i=0 to 4{
        res[i] = arg[i];
        res[i+4] = arg[i];
  }

  return res;
}


inline
fn FeistelSwap(stack u32[8] S) -> stack u32[8] {


  inline int i;

  for i=0 to 4 {
    reg u32 Si;
    Si = S[i];
    reg u32 S7i;
    S7i = S[7-i];
    Si ^= S7i;
    S[i] = Si;
  }

  for i=4 to 8 {
    reg u32 save;
    save = S[i];
    S[i] = S[8-i];
    S[8-i] = save;
  }

  return S;
}

inline
fn feedback_function_1(stack u32[8] S, reg u32[8] D) -> stack u32[8], reg u32[8] {

  S = FeistelSwap(S);
  
  inline int i;
  for i=0 to 8{
    reg u32 Si;
    Si = S[i];
    reg u32 Di;
    Di = D[i];
    Si^=Di;
    D[i] = Si;
  }

  return  S,D;

}

inline
fn feedback_function_2(stack u32[8] S, reg u32[8] D) -> stack u32[8], reg u32[8] {

  inline int i;

  for i=0 to 8 {
        D[i] ^= S[i];
  }

  return S, D;

}

inline
fn initialize_padding_constants(reg u64 Alen, reg u64 Mlen) -> reg u64, reg u64 {
  reg u64 constA;
  reg u64 constM;
  reg bool zf;
  
  ?{zf} = #TEST(Alen,31);

  if (zf) {
    constA = 5;
  } else {
    constA = 4;
  }

  ?{zf} = #TEST(Mlen,31);

  if (zf) {
    constM = 7;
  } else {
    constM = 6;
  }

  return constA, constM;
}

inline
fn schwaemm(stack u32[4] K, stack u32[8] N, reg u64 A_start, reg u64 A_end, reg u64 M_start, reg u64 M_end, reg u64 output_ptr) { 

  reg u32 constM;
  reg u32 constA;
  reg u64 M_lenght;
  reg u64 A_lenght;

  stack u32[8] SL;
  stack u32[4] SR;

  A_lenght = A_end;
  A_lenght -= A_start;
  inline int i;

  for i=0 to 8{
        SL[i] = N[i];
  }

  for i=0 to 4{
        SR[i] = K[i];
  }

  SL, SR = sparkle384_7(SL,SR); 

  // MAIN LOOP

  while (A_lenght > 32) {

    stack u32[8] W_result;

    reg u32[8] A_block;
    A_block = get_32x8_tab(A_start);

    SL, A_block = feedback_function_1(SL, A_block);
    W_result = W_128_256(SR);

    for i=0 to 8 {
        reg u32 Ai;
        reg  u32 Wi;
        Wi = W_result[i];
        Ai = A_block[i]^Wi;
        SL[i] = Ai;
    }

    SL, SR= sparkle384(SL,SR,7);

    A_start += 32;
    A_lenght = M_end;
    A_lenght -= M_start;
  }

  // LAST A BLOCK

  stack u8[24] t;

  inline int j;
  for j=0 to 24 {
    t[j] = 0;
  }

  reg u64 i;

  i=0;

  while (i<A_lenght) {
    t[i] = (u8)[A_start + i];
    i += 1;
  }
  
  // PADDING

  if i<16 {
    constA = 4;
  } else {
    constA = 5;
  }

  SR[0] ^= constA;

  reg u32[8] A_block;

  for j=0 to 6 {
    reg u32 t_val;
    t_val = t[u32 j];
    A_block[j] = t_val;
  }

  SL, SR = sparkle384_11(SL, SR);

  reg u64 output_ptr_offset;
  output_ptr_offset = 0;

  reg u32[8] M_block;

  M_lenght = M_end;
  M_lenght -= M_start;

  while (M_lenght > 32) {


    reg u32[8] feedback_1_result;
    stack u32[8] W_result;

    M_block = get_32x8_tab(M_start);

    SL, M_block = feedback_function_2(SL, M_block);

    inline int i;

    for i=0 to 8 {
            (u32)[output_ptr + output_ptr_offset + 4*i] = M_block[i];
    }

    output_ptr_offset += 32;

    SL, feedback_1_result = feedback_function_1(SL, M_block);
    W_result = W_128_256(SR);

    for i=0 to 8 {
        reg u32 f1i;
        f1i = feedback_1_result[i];
        reg u32 Wi;
        Wi = W_result[i];
        f1i ^= Wi;
        SL[i] = f1i;
    }

    SL, SR = sparkle384(SL,SR,7);

    M_start += 16;
    M_lenght = M_end;
    M_lenght -= M_start;
  }

  // LAST BLOCK

  stack u8[32] t;

  inline int j;
  for j=0 to 32 {
    t[j] = 0;
  }

  reg u64 i;
  ?{},i=#set0_64();

  while (i<M_lenght) {
    t[i] = (u8)[M_start + i];
    i += 1;
  }
  
  // PADDING

  if i<16 {
    constM = 6;
  } else {
    constM = 7;
  }

  SR[0] ^= constM;

  M_block = #copy_32(t);

  SL, M_block = feedback_function_2(SL, M_block);
  
  inline int i;
  
  for i=0 to 8 {
      (u32)[output_ptr + output_ptr_offset + 4*i] = M_block[i];
  }
  
  SL, SR = sparkle384_11(SL, SR);

}

