/*
A simple schwaemm implementation in Jasmin
*/

require "sparkle384.jazz"


inline
fn pre_sparkle_padding(reg u256 first_tab, inline u128 second_tab) -> stack u32[8], stack u32[4] {

  stack u32[8] x;
  stack u32[4] y;

  inline int i;

  inline u256 rotated_first_tab;
  inline u128 rotated_second_tab;

  rotated_first_tab = first_tab;
  rotated_second_tab = second_tab;

  for i=0 to 7 {
    x[i] = rotated_first_tab & 0xFF;
    rotated_first_tab >>= 16;
  }

  for i=0 to 3 {
    y[i] = rotated_second_tab & 0xFF;
    rotated_second_tab >>= 16;
  }

  return x,y;
}

inline
fn stack_u256_to_tab(stack u256 data) -> inline u32[8] {
  inline u32[8] tab;
  inline u256 rotated_data;
  inline int i;

  rotated_data = data;

  for i=0 to 7 {
    tab[i] = rotated_data & 0xFF;
    rotated_data >>= 32;
  }

  return tab;

}

inline
fn W_128_256(inline u128 arg) -> inline u256 {
  inline u256 res;
  inline u64 lower_half;
  inline u64 upper_half;

  lower_half = arg & 0xFFFFFFFFFFFFFFFF;
  arg >>= 64;
  upper_half = arg & 0xFFFFFFFFFFFFFFFF;

  res += (256u)upper_half;
  res <<= 64;
  res += (256u)lower_half;
  res <<= 64;
  res += (256u)upper_half;
  res <<= 64;
  res += (256u)lower_half;
  res <<= 64;

  return res;
}

inline
fn FeistelSwap(inline u256 S) -> inline u256 {

  inline u128 s_1;
  inline u128 s_2;
  inline u128 s_1_xor_s_2;
  inline u256 res;

  s_1 = S & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
  S >>= 128;
  s_2 = S & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;

  s_1_xor_s_2 = s_1 ^ s_2;
  res = (256u)s_2;
  res <<= 128;
  res += (256u)s_1_xor_s_2;

  return res;
}

inline
fn feedback_function_1(inline u256 S, inline u256 D) -> inline u256 {

  S = FeistelSwap(S);
  
  D^=S;

  return D;

}

inline
fn feedback_function_2(inline u256 S, inline u256 D) -> inline u256 {

  D^=S;

  return D;

}

inline
fn initialize_padding_constants(reg u64 Alen, reg u64 Mlen) -> reg u128, reg u128 {
  inline u128 constA;
  inline u128 constM;
  reg bool zf;

  ?{zf} = #TEST(Alen,31);

  if (zf) {
    inline u128 xored;
    xored = 1;
    xored <<= 2;
    constA = 0;
    constA ^= xored;
  } else {
    inline u128 xored;
    xored = 1;
    xored <<= 2;
    constA = 0;
    constA ^= xored;
  }

  ?{zf} = #TEST(Mlen,31);

  if (zf) {
    inline u128 xored;
    xored = 1;
    xored <<= 2;
    constM = 0;
    constM ^= xored;
  } else {
    inline u128 xored;
    xored = 1;
    xored <<= 2;
    constM = 0;
    constM ^= xored;
  }

  return constA, constM;
}

fn schwaemm(reg u128 K, reg u256 N, reg u64 A_start, reg u64 A_end, reg u64 M_start, reg u64 M_end, reg u64 output_ptr) -> reg u128 { 

  stack u256 SL;
  stack u128 SR;
  inline u32[8] SL_tab;
  inline u32[4] SR_tab;

  reg u64 A_lenght;
  reg u64 M_lenght;

  A_lenght = A_end;
  A_lenght -= A_start;
  M_lenght = M_end;
  M_lenght -= M_start;

  stack u64 A_lenght_save;
  stack u64 M_lenght_save;
  M_lenght_save = M_lenght;

  reg u128 constA;
  reg u128 constM;

  stack u128 constA_save;
  stack u128 constM_save;

  stack u32[8] x;
  stack u32[4] y;

  M_lenght = M_lenght_save;

  constA, constM = initialize_padding_constants(A_lenght, M_lenght);

  constA_save = constA;
  constM_save = constM;

  M_lenght_save = M_lenght;

  if A_lenght != 0 {
    while ((A_lenght) < 256) {
      inline u256 feedback_1_result;
      inline u256 W_result;

      inline u256 A_block;
      inline u32[8] A_block_tab;
      A_block = (256u)[A_start];

      stack u64 A_start_save;
      A_start_save = A_start;

      feedback_1_result = feedback_function_1(SL, A_block);
      W_result = W_128_256(SR);

      feedback_1_result ^= W_result;

      SL_tab = stack_u256_to_tab(SL);
      A_block_tab = stack_u256_to_tab(A_block);

      x,y = pre_sparkle_padding(feedback_1_result, SR);

      SL_tab, SR_tab = sparkle384(x,y,7);

      A_start = A_start_save;

      A_start += 32;

      A_lenght -= 32;
    }

    inline u256 feedback_1_result;
    inline u256 W_result;
    reg u256 zero;
    
    zero = #set0_256();
    stack u8[32] t;
    t.[u256 0] = zero;

    reg u256 A_block;
    reg u64 i;
    i=0;

    while (i<A_lenght) {
      t[i] = (u8)[A_start + i];
      i += 1;
    }
    t[i] = 1;

    A_block = t.[u256 0];

    constA = constA_save;

    SR ^= constA;

    constA_save = constA;

    feedback_1_result = feedback_function_1(SL, A_block);
    W_result = W_128_256(SR);
    feedback_1_result ^= W_result;

    x,y = pre_sparkle_padding(feedback_1_result, SR);

    SL_tab, SR_tab = sparkle384(x,y,11);

  }

  A_lenght_save = A_lenght;

  M_lenght = M_lenght_save;

  if M_lenght != 0 {
    while ((M_lenght) < 256) {

      M_lenght_save = M_lenght;

      inline u256 feedback_1_result;
      inline u256 W_result;

      inline u256 M_block;
      M_block = (256u)[M_start];

      feedback_1_result = feedback_function_1(SL, M_block);
      W_result = W_128_256(SR);

      feedback_1_result ^= W_result;

      x,y = pre_sparkle_padding(feedback_1_result, SR);

      SL_tab, SR_tab = sparkle384(x,y,7);

      M_start += 32;

      M_lenght = M_lenght_save; 

      M_lenght -= 32;

      M_lenght_save = M_lenght;
    }

    inline u256 feedback_1_result;
    inline u256 W_result;
    reg u256 zero;
    
    zero = #set0_256();
    stack u8[32] t;
    t.[u256 0] = zero;

    reg u256 M_block;
    reg u64 i;
    i=0;

    while (i<M_lenght) {
      t[i] = (u8)[M_start + i];
      i += 1;
    }
    t[i] = 1;

    M_block = t.[u256 0];

    constM = constM_save;

    SR ^= constM;

    constM_save = constM;

    feedback_1_result = feedback_function_2(SL, M_block);
    W_result = W_128_256(SR);
    feedback_1_result ^= W_result;

    x,y = pre_sparkle_padding(feedback_1_result, SR);

    SL_tab, SR_tab = sparkle384(x, y,11);
  }
  
  return constM;
}
