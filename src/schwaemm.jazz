/*
A simple Schwaemm implementation in Jasmin
*/

require "sparkle384.jazz"

inline
fn get_32x8_tab(reg u64 position) -> reg u32[8] {

  reg u32[8] tab;
  inline int i;

  for i=0 to 8 {
    tab[i] = (u32)[position + 2*i];
  }

  return tab;

}

inline
fn get_32x4_tab(reg u64 position) -> stack u32[4] {

  stack u32[4] tab;
  inline int i;

  for i=0 to 4{
    tab[i] = (u32)[position + 2*i];
  }

  return tab;

}

inline
fn W_128_256(stack u32[4] arg) -> stack u32[4], stack u32[8] {
  stack u32[8] res;
  inline int i;

  for i=0 to 4{
        res[i] = arg[i];
        res[i+4] = arg[i];
  }

  return arg, res;
}


inline
fn FeistelSwap(stack u32[8] S) -> stack u32[8] {


  inline int i;

  for i=0 to 4 {
    reg u32 Si;
    Si = S[i];
    reg u32 S7i;
    S7i = S[7-i];
    Si ^= S7i;
    S[i] = Si;
  }

  for i=4 to 8 {
    reg u32 save;
    save = S[i];
    S[i] = S[8-i];
    S[8-i] = save;
  }

  return S;
}

inline
fn feedback_function_1(stack u32[8] S, reg u32[8] D) -> stack u32[8], reg u32[8] {

  S = FeistelSwap(S);
  
  inline int i;
  for i=0 to 8{
    reg u32 Si;
    Si = S[i];
    reg u32 Di;
    Di = D[i];
    Si^=Di;
    D[i] = Si;
  }

  return  S,D;

}

inline
fn feedback_function_2(stack u32[8] S, reg u32[8] D) -> stack u32[8], reg u32[8] {

  inline int i;

  for i=0 to 8 {
        D[i] ^= S[i];
  }

  return S, D;

}

inline
fn schwaemm(stack u32[4] K, stack u32[8] N, reg u64 A_start, reg u64 A_end, reg u64 M_start, reg u64 M_end, reg u64 output_ptr) { 

  reg u32 constM;
  reg u32 constA;
  reg u64 M_lenght;
  reg u64 A_lenght;

  stack u32[8] SL;
  stack u32[4] SR;
  stack u32[8] W_result;

  A_lenght = A_end;
  A_lenght -= A_start;
  inline int i;

  for i=0 to 8{
        SL[i] = N[i];
  }

  for i=0 to 4{
        SR[i] = K[i];
  }

  SL, SR = sparkle384_7(SL,SR); 

  // MAIN LOOP

  if A_lenght!=0 {

    while (A_lenght > 32) {

      reg u32[8] A_block;
      A_block = get_32x8_tab(A_start);

      SL, A_block = feedback_function_1(SL, A_block);
      SR, W_result = W_128_256(SR);

      for i=0 to 8 {
          reg u32 Ai;
          reg  u32 Wi;
          Wi = W_result[i];
          Ai = A_block[i]^Wi;
          SL[i] = Ai;
      }

      SL, SR= sparkle384_7(SL,SR);

      A_start += 32;
      A_lenght = A_end;
      A_lenght -= A_start;
    }

    // LAST A BLOCK

    stack u8[32] t;

    inline int j;
    for j=0 to 32 {
      t[j] = 0;
    }

    reg u64 i;

    i=0;

    while (i<A_lenght) {
      t[i] = (u8)[A_start + i];
      i += 1;
    }
    
    // PADDING

    if i<32 {
      constA = 4<<24;
    } else {
      constA = 5<<24;
    }

    SR[3] ^= constA;

    SR, W_result = W_128_256(SR);

    reg u32[8] A_block;

    for j=0 to 8 {
      reg u32 t_val;
      t_val = t[u32 j];
      A_block[j] = t_val;
    }

  }

  SL, SR = sparkle384_11(SL, SR);

  reg u64 output_ptr_offset;
  output_ptr_offset = 0;

  reg u32[8] M_block;

  M_lenght = M_end;
  M_lenght -= M_start;

  if M_lenght !=0 {
    while (M_lenght > 32) {


      reg u32[8] feedback_1_result;
      stack u32[8] W_result;

      M_block = get_32x8_tab(M_start);

      SL, M_block = feedback_function_2(SL, M_block);

      inline int i;

      for i=0 to 8 {
              (u32)[output_ptr + output_ptr_offset + 4*i] = M_block[i];
      }

      output_ptr_offset += 32;

      SL, feedback_1_result = feedback_function_1(SL, M_block);
      SR, W_result = W_128_256(SR);

      for i=0 to 8 {
          reg u32 f1i;
          f1i = feedback_1_result[i];
          reg u32 Wi;
          Wi = W_result[i];
          f1i ^= Wi;
          SL[i] = f1i;
      }

      SL, SR = sparkle384_7(SL,SR);

      M_start += 32;
      M_lenght = M_end;
      M_lenght -= M_start;
    }

    // LAST BLOCK

    stack u8[32] t;

    inline int j;
    for j=0 to 32 {
      t[j] = 0;
    }

    reg u64 i;
    ?{},i=#set0_64();

    while (i<M_lenght) {
      t[i] = (u8)[M_start + i];
      i += 1;
    }
    
    // PADDING

    if i<32 {
      constM = 6<<24;
    } else {
      constM = 7<<24;
    }

    SR[3] ^= constM;

    M_block = #copy_32(t);

    SL, M_block = feedback_function_2(SL, M_block);
    
    inline int i;
    
    for i=0 to 8 {
        (u32)[output_ptr + output_ptr_offset + 4*i] = M_block[i];
    }

  }
  
  SL, SR = sparkle384_11(SL, SR);

  inline int i;

  for i=0 to  4 {
        SR[i] ^= K[i];
        (u32)[output_ptr + output_ptr_offset + 4*i] = M_block[i];
  }

}

