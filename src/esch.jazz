/*
A simple Esch implementation in Jasmin
*/

require "sparkle_suite.jazz"
require "sparkle384.jazz"

inline
fn l(reg u32 x) -> reg u32{
  reg u32 shifted_x;

  shifted_x = x;
  shifted_x <<r= 16;

  x &= 0xffff;

  x ^= shifted_x;

  return x;
}

inline
fn M3(reg ptr u32[6] tab) -> reg ptr u32[6] {
  reg u32 t_x, t_y;

  t_x = tab[0];
  t_x ^= tab[2];
  t_y = tab[1];
  t_y ^= tab[3];

  t_x = l(t_x);
  t_y = l(t_y);

  tab[0] ^= t_y;
  tab[2] ^= t_y;

  tab[1] ^= t_x;
  tab[3] ^= t_x;

  tab[4] = t_y;
  tab[5] = t_x;

  return tab;
}

fn 
M3_XOR_S(reg u64 M_start, reg ptr u32[12] S) -> reg ptr u32[12] {
  reg u32 zero;
  ?{},zero = #set0_32();

  inline int i;
  stack u32[6] M3_tab;

  for i=0 to 4 {
    M3_tab[i] = (u32)[M_start + 4*i];
  }

  M3_tab[4] = zero;
  M3_tab[5] = zero;

  M3_tab = M3(M3_tab);

  for i=0 to 6 {
    reg u32 l;
    l = M3_tab[i];
    S[i] ^= l;
  }

  return S;
}

fn esch(reg u64 M_start, reg u64 M_end, reg u64 output_ptr) { 

  reg u32 constM;
  reg u64 M_lenght;

  M_lenght = M_end;
  M_lenght -= M_start;

  stack u32[12] S;

  reg u32 zero;
  ?{},zero = #set0_32();

  inline int j;
  for j=0 to 12 {
    S[j] = zero;
  }

  // MAIN LOOP

  while (M_lenght > 16) {
    S = M3_XOR_S(M_start, S);  // padd + apply M3

    S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);

    M_start += 16;
    M_lenght = M_end;
    M_lenght -= M_start;
  }


  // LAST BLOCK

  stack u8[24] t;

  for j=0 to 24 {
    t[j] = 0;
  }

  reg u64 i;
  ?{},i=#set0_64();

  while (i<M_lenght) {
    t[i] = (u8)[M_start + i];
    i += 1;
  }
  
  // PADDING

  if i<16 {
    reg u8 var_1;
    var_1 = 0x80;
    t[u8 i] = var_1;
    constM = 1<<24;
  } else {
    constM =2<<24;
  }

  t[u32 0:6] = M3(t[u32 0:6]);

  S[5] ^= constM;

  for j=0 to 6 {
    reg u32 t_val;
    t_val = t[u32 j];
    S[j] ^= t_val;
  }

  S[0:8], S[8:4] = sparkle384_11(S[0:8], S[8:4]);

  // D_0
   
  inline int j;

  for j=0 to 4 {
    (u32)[output_ptr + 4*j] = S[j];
  }

  S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);

  // D_1

  inline int k;

  for k=0 to 4 {
    (u32)[output_ptr + 16 + 4*k] = S[k];
  }


}

