/*
A simple Esch implementation in Jasmin
*/

from sparkle require "sparkle384.jazz"
from functions require "M3.jazz"

fn 
M3_XOR_S(reg u64 M_start, reg ptr u32[12] S) -> reg ptr u32[12] {
  reg u32 zero;
  ?{},zero = #set0_32();

  inline int i;
  stack u32[6] M3_tab;

  for i=0 to 4 {
    M3_tab[i] = (u32)[M_start + 4*i];
  }

  M3_tab[4] = zero;
  M3_tab[5] = zero;

  M3_tab = M3(M3_tab);

  for i=0 to 6 {
    reg u32 l;
    l = M3_tab[i];
    S[i] ^= l;
  }

  return S;
}

fn esch(reg u64 M_start, reg u64 M_end, reg u64 output_ptr) { 

  reg u32 constM;
  reg u128 D_0;
  reg u128 D_1;
  reg u64 M_lenght;

  M_lenght = M_end;
  M_lenght -= M_start;

  stack u32[12] S;

  reg u32 zero;
  ?{},zero = #set0_32();

  inline int j;
  for j=0 to 12 {
    S[j] = zero;
  }

  // MAIN LOOP

  while (M_lenght > 16) {
    S = M3_XOR_S(M_start, S);  // padd + apply M3

    S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);

    M_start += 16;
    M_lenght = M_end;
    M_lenght -= M_start;
  }


  // LAST BLOCK

  stack u32[4] M_block;

  stack u8[24] t;

  inline int j;

  for j=0 to 24 {
    t[j] = 0;
  }

  reg u64 i;
  i=#set0_64();

  while (i<M_lenght) {
    t[i] = (u8)[M_start + i];
    i += 1;
  }
  
  // PADDING

  if i<16 {
    reg u8 var_1;
    var_1 = 0x80;
    t[u8 i] = var_1;
    constM = 1<<24;
  } else {
    constM =2<<24;
  }

  t[u32 0:6] = M3(t[u32 0:6]);

  inline int index;

  S[5] ^= constM;

  inline int i;

  for i=0 to 6 {
    reg u32 t_val;
    t_val = t[u32 i];
    S[i] ^= t_val;
  }

  S[0:8], S[8:4] = sparkle384_11(S[0:8], S[8:4]);

  // D_0
   
  inline int j;

  for j=0 to 4 {
    (u32)[output_ptr + 4*j] = S[j];
  }

  S[0:8], S[8:4] = sparkle384_7(S[0:8], S[8:4]);

  // D_1

  inline int k;

  for k=0 to 4 {
    (u32)[output_ptr + 16 + 4*k] = S[k];
  }


}

